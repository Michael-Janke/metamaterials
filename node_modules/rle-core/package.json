{
  "_args": [
    [
      {
        "raw": "rle-core@~0.0.7",
        "scope": null,
        "escapedName": "rle-core",
        "name": "rle-core",
        "rawSpec": "~0.0.7",
        "spec": ">=0.0.7 <0.1.0",
        "type": "range"
      },
      "/home/travis/build/shark39/metamaterials/node_modules/rle-ndarray"
    ]
  ],
  "_from": "rle-core@>=0.0.7 <0.1.0",
  "_id": "rle-core@0.0.8",
  "_inCache": true,
  "_location": "/rle-core",
  "_npmUser": {
    "name": "mikolalysenko",
    "email": "mikolalysenko@gmail.com"
  },
  "_npmVersion": "1.2.24",
  "_phantomChildren": {},
  "_requested": {
    "raw": "rle-core@~0.0.7",
    "scope": null,
    "escapedName": "rle-core",
    "name": "rle-core",
    "rawSpec": "~0.0.7",
    "spec": ">=0.0.7 <0.1.0",
    "type": "range"
  },
  "_requiredBy": [
    "/rle-extents",
    "/rle-ndarray",
    "/rle-rasterize",
    "/rle-repair"
  ],
  "_resolved": "https://registry.npmjs.org/rle-core/-/rle-core-0.0.8.tgz",
  "_shasum": "a7fcabce470e71c6e9d86e3dc5cc612ce9d1e17e",
  "_shrinkwrap": null,
  "_spec": "rle-core@~0.0.7",
  "_where": "/home/travis/build/shark39/metamaterials/node_modules/rle-ndarray",
  "author": {
    "name": "Mikola Lysenko"
  },
  "bugs": {
    "url": "https://github.com/mikolalysenko/rle-core/issues"
  },
  "dependencies": {},
  "description": "Core tools for working with narrow band level sets in JavaScript",
  "devDependencies": {
    "rle-sample": "~0.0",
    "tap": "~0.3.3"
  },
  "directories": {
    "test": "test",
    "lib": "lib"
  },
  "dist": {
    "shasum": "a7fcabce470e71c6e9d86e3dc5cc612ce9d1e17e",
    "tarball": "https://registry.npmjs.org/rle-core/-/rle-core-0.0.8.tgz"
  },
  "gitHead": "e0cc6ff9fd4cb378ca13600040811dfa1448714e",
  "homepage": "https://github.com/mikolalysenko/rle-core#readme",
  "keywords": [
    "voxels",
    "levelset",
    "potential",
    "solid",
    "cad",
    "geometry",
    "modeling",
    "shapes",
    "physics",
    "3D",
    "webgl"
  ],
  "license": "BSD",
  "main": "index.js",
  "maintainers": [
    {
      "name": "mikolalysenko",
      "email": "mikolalysenko@gmail.com"
    }
  ],
  "name": "rle-core",
  "optionalDependencies": {},
  "readme": "`rle-core`\n=========\n...is the central package in the [`rle` narrowband level set family of packages](https://github.com/mikolalysenko/rle-core).  These tools are currently a work in progress, so expect many changes in the coming months.  This package contains fundamental data structures for working with multiphase narrowband level sets. Higher order algorithms are to be built on top of these tools.\n\nOverview\n========\nA multiphase solid is an extension of the usual concept of a solid object to structures with multiple distinct material phases.  One can recover the usual definition of a solid by just taking the number of phases = 2.\n\nA narrowband level set is a sparse representation of a level set as it is sampled on a regular grid.  However, instead of storing an entire dense array of voxels, narrowband methods only store voxels which are near the boundary of the level set.  This means that their storage and processing requirements are typically O(n^2/3) of the size of a dense level set.\n\nThe `rle-*` libraries are split into several components, which we could group coarsely into two layers\n\nFoundation\n----------\n* [`rle-core`](https://github.com/mikolalysenko/rle-core): Foundational data structures and algorithms\n* [`rle-sample`](https://github.com/mikolalysenko/rle-sample): Algorithms for sampling level sets\n* [`rle-stencils`](https://github.com/mikolalysenko/rle-stencils): Commonly used stencils\n* [`rle-mesh`](https://github.com/mikolalysenko/rle-mesh): Surface extraction and meshing operations\n* [`rle-funcs`](https://github.com/mikolalysenko/rle-funcs): Generic surface processing primitives.\n* [`rle-classify`](https://github.com/mikolalysenko/rle-classify): Primitive classification and queries.\n\nExtensions\n----------\n* [`rle-components`](https://github.com/mikolalysenko/rle-components): Connected component labelling and extraction.\n* [`rle-csg`](https://github.com/mikolalysenko/rle-csg): Constructive solid geometry (aka boolean set operations)\n* [`rle-repair`](https://github.com/mikolalysenko/rle-repair): Repair and validation methods\n* [`rle-rasterize`](https://github.com/mikolalysenko/rle-rasterize): Rasterizes meshes into level sets.\n* [`rle-morphology`](https://github.com/mikolalysenko/rle-morphology): Mathematical morphology for level sets.\n\n\nGetting Started\n===============\nTo install the core library, you grab it from npm:\n\n    npm install rle-core\n    \nBy itself rle-core probably isn't enough to do anything terribly interesting.  So if you want to do something cool, you will probably want to import one of the other libraries - like [`rle-sample`](https://github.com/mikolalysenko/rle-sample), which lets you sample level sets; or [`rle-mesh`](https://github.com/mikolalysenko/rle-mesh) which lets you convert level sets into meshes.  To install those packages, just do:\n\n    npm install rle-sample rle-mesh\n    \nThen you can use them to generate a boxy level set and convert it into a mesh:\n\n    var box = require(\"rle-sample\").solid.dense([-10, -10, -10], [10, 10, 10], function(x) {\n      return Math.max(Math.abs(x[0]), Math.abs(x[1]), Math.abs(x[2]));\n    });\n    \n    var mesh = require(\"rle-mesh\")(box);\n    \nDemos\n=====\nIf you want to see some examples of what you can do with narrow band level sets, here are a few demos:\n\n* [Isosurface mesh extraction](http://mikolalysenko.github.com/rle-mesh/examples/simpleMultiphase/www/index.html)\n* [Game of Life in 3D](http://mikolalysenko.github.com/rle-core/life3d/index.html)\n* [Morphology Demo](http://mikolalysenko.github.com/rle-morphology/example/www/index.html)\n\n`rle-core` API\n==============\n`rle-core` contains iterators and data structures.  There are basically two kinds of RLE volumes, StaticVolumes and DynamicVolumes.  Whichever one you pick should depend on the application you have in mind.  If your volume is short lived, and you are going to be modifying it a lot, use a DynamicVolume.  Accessing StaticVolumes is around 10% more efficient, and they use less memory since they are built on top of typed arrays.  However, constructing a StaticVolume is pretty expensive and so don't build one if you are only going to keep it around for a short time.\n\n## `StaticVolume` and `DynamicVolume`\n\nBoth of these classes have a pretty similar structure.  They each have 3 fields which coorespond to the data stored in the runs:\n\n* `coords`: An array of 3 arrays corresponding to the x/y/z coordinates of the start of each run.\n* `distances`: An array of floats representing the distance to phase boundary for each run.\n* `phases`: An array of different phases for each run, represented as 32 bit signed integers\n\n`new`ing a volume with no arguments gives an empty volume.  The volumes define the following methods:\n\n### `volume.clone()`\nMakes a deep copy of the volume.\n\n### `volume.length()`\nReturns the number of runs in the volume\n\n### `volume.bisect(coord, lo, hi)`\nDoes a binary search to locate coord within the volume.  `lo` and `hi` are optional bounds on the lower/upper bounds of the coordinate within the volume.\n\n### `volume.push(x, y, z, distance, phase)` (DynamicVolume only)\nAppends a run to the volume at x/y/z with given phase and distance to boundary\n\n### `volume.pop()` (DynamicVolume only)\nRemoves the last run from the volume.\n\n### `volume.toStatic()` (DynamicVolume only)\nReturns a static version of the volume\n\n### `volume.toDynamic()` (StaticVolume only)\nReturns a dynamic version of the volume\n\n## `StencilIterator` and `MultiIterator`\n\nThere are also two different types of iterators.  `StencilIterator`s and `MultiIterator`s.  The main difference is that `StencilIterator` is optimized to iterate over a single volume, while `MultiIterator` iterates over several volumes simultaneously.  To create a stencil iterator, you call:\n\n### `core.beginStencil(volume, stencil)`\nWhich returns a stencil iterator for the given volume with the given stencil pattern (for example, Moore neighborhood, von Neumann, etc.)\n\nFor multi iterators, it is a similar pattern.\n\n### `core.beginMulti(volumes, stencil)`\nHere volumes is an array of volumes, and stencil is again some pattern.\n\nEach of the iterator types has the following common data:\n* `volume`(`s`): A single volume/array of volumes referencing the volume which is currently being iterated over.\n* `stencil`: The stencil pattern\n* `ptrs`: An array of pointers into the volume, with one entry per point in the stencil\n* `coord`: The current coordinates of the the stencil.\n\nAnd similarly, all the stencils define the following methods\n\n### `iter.clone()`\nReturns a deep copy of th iterator\n\n### `iter.hasNext()`\nReturns true if the iterator can be advanced, false otherwise\n\n### `iter.next()`\nAdvances the iterator forward one run\n\n### `iter.seek(coord)`\nSets the iterator coordinate to `coord`\n\n### `iter.getValues(phases, distances)`\nRetrieves the phases/distance-to-phase-boundary for each point in the iterator.  \n\n### `iter.subiterator(n)` (MultiIterator only)\nReturns the stencil iterator associated to volume `n` at the location of the current multiiterator.\n\n## Miscellaneous stuff\n\nFinally, `rle-core` also defines the following constants:\n\n* `NEGATIVE_INFINITY`: A special value representing the start of a coordinate.  This is not the same as `Number.NEGATIVE_INFINITY`\n* `POSITIVE_INFINITY`: A special value representing the end coordinate of the volume.  Not the same as `Number.POSITIVE_INFINITY`\n* `EPSILON`: A small floating point number.\n\nAnd two helper methods:\n\n### `compareCoord(a, b)`\nCompares two coordinates lexicographically\n\n### `saturateAbs(x)`\nReturns |x| clamped to [0,1]\n\nAcknowledgements\n================\n(c) 2012-2013 Mikola Lysenko (mikolalysenko@gmail.com).  BSD License.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/mikolalysenko/rle-core.git"
  },
  "scripts": {
    "test": "tap ./test"
  },
  "version": "0.0.8"
}
